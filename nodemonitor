#! /usr/bin/bash
#
# BITCOIN NODE MONITOR
#
# Questo lavoro è distribuito sotto licenza Creative Commons Attribution 4.0 International License.
# Per visualizzare una copia di questa licenza, visita http://creativecommons.org/licenses/by-nc/4.0/
#
# L'utente è libero di copiare, distribuire e migliorare questo script
# È richiesto che l'autore originale sia sempre debitamente attribuito
# Non puoi utilizzare questo codice per scopi commerciali
#
# Autore: LeChuck
# Contatti: Telegram - @ilPirataLeChuck
#
# Per segnalare bug o fornire suggerimenti, si prega di contattare l'autore tramite Telegram all'indirizzo sopra indicato.


TITLE="BLOCKCHAIN NODE MONITOR"
REFRESH=60 #(in secondi)
WAIT_ON_ERROR=30 #(in secondi)
BLOCKCHAIN="/mnt/blockchain"
BLOCKS_LIST_DIM="AUTO" #Quanti blocchi visualizzare a partire dall'ultimo (AUTO per riempire tutta la schermata)
BLOCKS_LIST_MAX=15 #Numero massimo di blocchi da visualizzare (quando BLOCK_LIST_DIM è su "AUTO")

#STIMA COSTO FEES IN BASE AL NUMERO DI BLOCCHI ENTRO CUI DEVE ESSERE INCLUSA LA TRANSAZIONE
# -> è possibile personalizzare mettendo il numero di blocchi che si vuole
STIMA_BLOCCHI=("1" "6" "144") #es. 6 = 1h, 144 = 1 giorno, 1008 = 1 settimana ecc ecc

#Mostra il controvalore in BTC degli euro specificati nell'array
EURO=("1" "50" "1000" "1000000")

# Metodo per calcolare la stima del prossimo halving
# METODO 1: Calcola la media degli ultimi 210.000 blochhi (un ciclo) e la moltiplica per il num di blocchi al prossimo halving
# METODO 2: Prende lo stesso tempo dal ciclo scorso
# METODO 3: Considera la velocità media di creazione blocchi dall'ultimo difficulty adjustment
# METODO 4: Considera la velocità più alta e più bassa dei cicli precedenti e restituisce la forbice
metodo=4


#URL esterno per leggere valore BTC
EXT_URL="https://api.blockchain.com/v3/exchange/tickers/BTC-EUR"

daemon="bitcoind" #Nome del daemon da verificare

export TZ=Europe/Rome

COLUMNS=`tput cols`
ROWS=`tput lines`

USEDROWS=41 #Numero di righe usate per scritte e titoli (per calcolare quante ne rimangono per visualizzare i blocchi)
if [ $BLOCKS_LIST_DIM == "AUTO" ]; then
  if [ $ROWS -gt $USEDROWS ]; then
    BLOCKS_LIST_DIM=$((ROWS - USEDROWS))
    if [ $BLOCKS_LIST_DIM -gt $BLOCKS_LIST_MAX ]; then BLOCKS_LIST_DIM=$BLOCKS_LIST_MAX; fi
  else
    BLOCKS_LIST_DIM=2
  fi
fi

CLI="bitcoin-cli -datadir=$BLOCKCHAIN"
firstrun=true
media_tx_per_block=0

############
# FUNZIONI #
############

print_number(){
  numero=$1
  # salva il segno del numero (se presente)
  if [[ "$numero" =~ ^[+-] ]]; then
    segno="${BASH_REMATCH[0]}"
    numero="${numero#$segno}"
  else
    segno=""
  fi
  # salva la parte intera del numero
  parte_intera=$(echo "$numero" | awk -F. '{print $1}')
  # salva la parte decimale del numero (se presente), con virgola
  if [[ "$numero" =~ \. ]]; then
    parte_decimale=",${numero##*.}"
  else
    parte_decimale=""
  fi
  # aggiunge un punto ogni 3 cifre per le migliaia nella parte intera
  parte_intera_con_virgole=$(echo "$parte_intera" | sed ':a;s/\B[0-9]\{3\}\>/.&/;ta')
  # ricostruisce il numero completo con il segno, la parte intera coi punti e la parte decimale
  numero_con_virgole="${segno}${parte_intera_con_virgole}${parte_decimale}"
  echo $numero_con_virgole
}

fullrow() {
 REPEATS=$(( $COLUMNS / ${#1} ))
 for (( i = 1 ; i <= $REPEATS ; i++ ))
 do
   echo -n "$1"
 done
 LEFTOVER=$(( $COLUMNS % ${#1} ))
 if [[ $LEFTOVER -ne 0 ]]
 then
  SOTTOSTRINGA=${1:0:LEFTOVER}
  echo -n "$SOTTOSTRINGA"
 fi
 echo
}

empty_spaces(){
  for ((i=0;i<$1;i++))
  do
    echo -n " "
  done
}

centertext(){
  text=$@
  len=${#text}
  spaces_l=$((($COLUMNS-$len)/2))
  spaces_r=$((COLUMNS-len-spaces_l))
  empty_spaces $spaces_l
  echo -n "$text"
  empty_spaces $spaces_r
  echo
}

centertext_fullrow(){
 text=$1
 len1=${#1}
 len2=${#2}
 len_tot=$((len1 + 2*len2 + 2))
 if [[ $len_tot -gt $COLUMNS ]]; then
   echo $text
 else
   spaces=$((COLUMNS - len1 - 2))
   spaces_l=$((spaces/2))
   spaces_r=$((spaces-spaces_l))
   repeats_l=$((spaces_l/len2))
   for ((i=1;i<=$repeats_l;i++))
   do
     echo -n "$2"
   done
   leftover_l=$((spaces_l % len2))
   if [[ $leftover_l -ne 0 ]]; then
     sottostringa_l=${2:0:leftover_l}
     echo -n "$sottostringa_l"
   fi
   echo -n " $text "
   repeats_r=$((spaces_r/len2))
   for ((i=1;i<=$repeats_r;i++)); do
     echo -n "$2"
   done
   leftover_r=$((spaces_r % len2))
   if [[ $leftover_r -ne 0 ]]; then
     sottostringa_r=${2:0:leftover_r}
     echo -n "$sottostringa_r"
   fi
   echo
 fi
}

lcr_text(){
  text1=$1
  text2=$2
  text3=$3
  tottext="$text1$text2$text3"
  len=${#tottext}
  min_len=$((len+2))

  if [ -n "$4" ]; then change_color $4; fi
  echo -n $text1
  if [ -n "$4" ]; then change_color reset; fi

  if [[ $min_len -lt $COLUMNS ]]; then
    spaces=$((COLUMNS - len))
    len_l=${#text1}
    len_c=${#text2}
    len_r=${#text3}
    space_l=$(( ((COLUMNS - len_c) / 2) - len_l ))
    space_r=$((spaces - space_l))
    if [[ space_l -lt 1 ]]; then
      space_r=$((space_r+space_l-1))
      space_l=1
    elif [[ space_r -lt 1 ]]; then
      space_l=$((space_l+space_r-1))
      space_r=1
    fi
    empty_spaces $space_l
    echo -n $text2
    empty_spaces $space_r
  else

    if [ -n "$5" ]; then change_color $5; fi
    echo $text2
    if [ -n "$5" ]; then change_color reset; fi

  fi

  if [ -n "$6" ]; then change_color $6; fi
  echo $text3
  if [ -n "$6" ]; then change_color reset; fi

}

lr_text() {
  text1=$1
  text2=""
  text3=$2
  opt1=""
  opt2=""
  if [ $# -gt 2 ]; then
    opt1=$3
    if [ $# -gt 3 ]; then
      opt2=$4
    fi
  fi
  lcr_text "$text1" "$text2" "$text3" "$opt1" "" "$opt2"
}

waitecho() {
 for (( i = 0 ; i < $1 ; i++ ))
 do
  echo -n "."
  sleep 1
 done
 echo
}

waitbar() {
 COLS=$COLUMNS
 TOT_TIME=$1
 attesa=$(bc<<<"scale=2;$TOT_TIME/$COLS")
 for ((i=1;i<=$COLUMNS;i++))
 do
  echo -n "."
  sleep $attesa
 done
 echo
}

human_readable_number() {
 number=$1
 suffisso="${2:-}" #di default nessun suffisso
 prefissi=("" "k" "M" "G" "T" "P" "E" "Z" "Y" "R" "Q")
 scala="${3:-1000}" #di default 1000
 check=$(echo "$number/1" | bc)
 for prefisso in "${prefissi[@]}"; do
   if [[ $check -ge $scala ]]; then
     check=$((check/scala))
     number=$(echo "scale=2; $number / $scala" | bc)
   else
     unit=$prefisso
     break
   fi
 done
 echo "$number$unit$suffisso"
}

human_readable_bytes() {
 human_readable_number $1 "B" 1024
}

seconds_converter() {
  SECONDI=$1
  if [ $SECONDI -lt 0 ]; then
    SECONDI=$((SECONDI * -1))
    TEMPO="negativo"
  else
    TEMPO="positivo"
  fi
  SEC_MIN=60
  SEC_ORA=$(($SEC_MIN*60))
  SEC_GIO=$(($SEC_ORA*24))
  SEC_ANN=$(($SEC_GIO*365))
  SEC_MES=$(($SEC_ANN/12))

  ANNI=$(($SECONDI / $SEC_ANN))
  SEC=$(($SECONDI % $SEC_ANN))
  MESI=$(($SEC / $SEC_MES))
  SEC=$(($SEC % $SEC_MES))
  GIORNI=$(($SEC / $SEC_GIO))
  SEC=$(($SEC % $SEC_GIO))
  ORE=$(($SEC / $SEC_ORA))
  SEC=$(($SEC % $SEC_ORA))
  MINUTI=$(($SEC / $SEC_MIN))
  SECONDI=$(($SEC % $SEC_MIN))

  if [ $TEMPO == "negativo" ]; then echo -n "- "; fi
  if [ $ANNI -gt 0 ]; then echo -n $ANNI; echo -n "y "; fi
  if [ $MESI -gt 0 ]; then echo -n $MESI; echo -n "m "; fi
  if [ $GIORNI -gt 0 ]; then echo -n $GIORNI; echo -n "d "; fi
  if [ $ORE -gt 0 ]; then echo -n $ORE; echo -n "h "; fi
  if [ $MINUTI -gt 0 ]; then echo -n $MINUTI; echo -n "m "; fi
  if [ $SECONDI -gt 0 ]; then echo -n $SECONDI; echo "s"; fi
}

sat2btc() {
  scale=8
  divisore=10
  sats=$1
  if [ $sats -eq 0 ]; then echo $sats; exit; fi
  while [ true ]; do
    if [ $scale -eq 0 ]; then break; fi
    check=$((sats % divisore))
    if [ $check -eq 0 ]; then
      scale=$((scale-1))
      divisore=$((divisore*10))
    else
      break
    fi
  done
  BTC=$(echo "scale=$scale; $sats/100000000" | bc)
  echo $BTC
}

mined_bitcoins() {
  BLOCCO=$1
  REWARD=50
  HALVING=210000
  TOT_BTC_s=0
  REWARD_s=$((REWARD*100000000))
  NUM_HALV=0
  BLOCCHI=$(( $BLOCCO + 1)) #Si conta anche il blocco 0
  while [ $BLOCCHI -gt 0 ]; do
    if [ $BLOCCHI -gt $HALVING ]; then
      TOT_BTC_s=$((TOT_BTC_s + (HALVING * REWARD_s) ))
      BLOCCHI=$((BLOCCHI - HALVING))
      REWARD_s=$((REWARD_s / 2))
      NUM_HALV=$((NUM_HALV + 1))
    else
      TOT_BTC_s=$((TOT_BTC_s + (BLOCCHI * REWARD_s) ))
      BLOCCHI=0
    fi
  done
  TOT_BTC=$(sat2btc $TOT_BTC_s)
  REWARD=$(sat2btc $REWARD_s)
  echo $TOT_BTC
}

get_halving_number() {
  BLOCCO=$1
  HALVING=$((BLOCCO / 210000))
  if [ $HALVING -gt 33 ]; then HALVING=33; fi
  echo $HALVING
}

get_reward() {
  BLOCCO=$1
  REWARD=$((50*10**8)) #50 BTC in satoshi
  HALVING=$(get_halving_number $BLOCCO)
  while [ true ]; do
    if [ $HALVING -eq 0 ]; then break; fi
    REWARD=$((REWARD / 2))
    HALVING=$((HALVING -1))
  done
  REW=$(sat2btc $REWARD)
  echo $REW
}

halving_progress() {
 BLOCK=$1
 BLOCKS_FROM_HALVING=$(($BLOCK % 210000))
 LAST_HALVING=$(($BLOCK-$BLOCKS_FROM_HALVING))
 NEXT_HALVING=$(($LAST_HALVING + 210000))
 BLOCKS_TO_HALVING=$(($NEXT_HALVING - $BLOCK))
 BLOCKS_FROM_HALVING=$(($BLOCK - $LAST_HALVING))
 LAST_HALV_NUM=$(get_halving_number $BLOCK)
 NEXT_HALV_NUM=$((LAST_HALV_NUM + 1))
 if [[ $2 -eq 1 ]]; then
   L1_STRING="HALV #$LAST_HALV_NUM <"
   L2_STRING="| $BLOCKS_FROM_HALVING |"
   R1_STRING="> HALV #$NEXT_HALV_NUM"
   R2_STRING="| $BLOCKS_TO_HALVING |"
   C_STRING="(X)"
 elif [[ $2 -eq 2 ]]; then
   L1_STRING="HALV #$LAST_HALV_NUM"
   L2_STRING=" ($BLOCKS_FROM_HALVING) <"
   R1_STRING="HALV #$NEXT_HALV_NUM"
   R2_STRING="> ($BLOCKS_TO_HALVING) "
   C_STRING="O"
 fi
 MIN_STRING="$L1_STRING$L2_STRING$C_STRING$R1_STRING$R2_STRING"
 MIN_STR_LEN=${#MIN_STRING}
 if [ $MIN_STR_LEN -lt $COLUMNS ]; then
  TOT_BAR=$(($COLUMNS - $MIN_STR_LEN))
  BLOCKS_PER_SPACE=$(echo "scale=5; 210000 / $TOT_BAR" | bc)
  L_SPACES=$(echo "scale=0; $BLOCKS_FROM_HALVING / $BLOCKS_PER_SPACE" | bc)
  R_SPACES=$((TOT_BAR - L_SPACES))
  L_HALF1=$((L_SPACES / 2))
  L_HALF2=$((L_SPACES - L_HALF1))
  R_HALF2=$((R_SPACES / 2))
  R_HALF1=$((R_SPACES - R_HALF2))
  if [[ $2 -eq 1 ]]; then
    echo -n $L1_STRING
    for ((i=1;i<=$L_HALF1;i++)); do echo -n "-"; done
    echo -n $L2_STRING
    for ((i=1;i<=$L_HALF2;i++)); do echo -n "-"; done
    echo -n $C_STRING
    for ((i=1;i<=$R_HALF1;i++)); do echo -n "-"; done
    echo -n $R2_STRING
    echo $R1_STRING
  elif [[ $2 -eq 2 ]]; then
    echo -n "$L1_STRING$L2_STRING"
    for ((i=1;i<=$L_SPACES;i++)); do echo -n "-"; done
    echo -n $C_STRING
    for ((i=1;i<=$R_SPACES;i++)); do echo -n "-"; done
    echo "$R2_STRING$R1_STRING"
  fi
 else
  echo "$L1_STRING $L2_STRING"
  echo "$R2_STRING $R1_STRING"
 fi
}

difficulty_progress() {
 BLOCK=$1
 BLOCKS_FROM_DIFF_CHANGE=$(($BLOCK % 2016))
 LAST_DIFF_CHANGE=$(($BLOCK-$BLOCKS_FROM_DIFF_CHANGE))
 NEXT_DIFF_CHANGE=$(($LAST_DIFF_CHANGE+2016))
 BLOCKS_TO_DIFF_CHANGE=$(($NEXT_DIFF_CHANGE-$BLOCK))
 if [[ $2 -eq 1 ]]; then
   L1_STRING="#$LAST_DIFF_CHANGE <"
   L2_STRING="| $BLOCKS_FROM_DIFF_CHANGE |"
   R1_STRING="> #$NEXT_DIFF_CHANGE"
   R2_STRING="| $BLOCKS_TO_DIFF_CHANGE |"
   C_STRING="(X)"
 elif [[ $2 -eq 2 ]]; then
   L1_STRING="#$LAST_DIFF_CHANGE"
   L2_STRING=" ($BLOCKS_FROM_DIFF_CHANGE) <"
   R1_STRING="#$NEXT_DIFF_CHANGE"
   R2_STRING="> ($BLOCKS_TO_DIFF_CHANGE) "
   C_STRING="O"
 fi
 MIN_STRING="$L1_STRING$L2_STRING$C_STRING$R2_STRING$R1_STRING"
 MIN_STR_LEN=${#MIN_STRING}
 if [ $MIN_STR_LEN -lt $COLUMNS ]; then
  TOT_BAR=$(($COLUMNS - $MIN_STR_LEN))
  BLOCKS_PER_SPACE=$(echo "scale=5; 2016/$TOT_BAR" | bc)
  L_SPACES=$(echo "scale=0; $BLOCKS_FROM_DIFF_CHANGE / $BLOCKS_PER_SPACE" | bc)
  R_SPACES=$((TOT_BAR - L_SPACES))
  L_HALF1=$((L_SPACES / 2))
  L_HALF2=$((L_SPACES - L_HALF1))
  R_HALF2=$((R_SPACES / 2))
  R_HALF1=$((R_SPACES - R_HALF2))
  if [[ $2 -eq 1 ]]; then
    echo -n $L1_STRING
    for ((i=1;i<=$L_HALF1;i++)); do echo -n "-"; done
    echo -n $L2_STRING
    for ((i=1;i<=$L_HALF2;i++)); do echo -n "-"; done
    echo -n $C_STRING
    for ((i=1;i<=$R_HALF1;i++)); do echo -n "-"; done
    echo -n $R2_STRING
    for ((i=1;i<=$R_HALF2;i++)); do echo -n "-"; done
    echo $R1_STRING
  elif [[ $2 -eq 2 ]]; then
    echo -n "$L1_STRING$L2_STRING"
    for ((i=1;i<=$L_SPACES;i++)); do echo -n "-"; done
    echo -n $C_STRING
    for ((i=1;i<=$R_SPACES;i++)); do echo -n "-"; done
    echo "$R2_STRING$R1_STRING"
  fi
 else
  echo "$L1_STRING $L2_STRING"
  echo "$R2_STRING $R1_STRING"
 fi
}

readable_date(){
  READABLE_DATE=$(date -d @"$1" +"%d/%m/%Y alle %H:%M:%S")
  echo $READABLE_DATE
}

change_color() {
 part1="\033["
 part2="m"
 string=""
 for var in "$@"; do
  col=""
  case $var in
    bold)
      col=1
    ;;
    light)
      col=2
    ;;
    italicus)
      col=3
    ;;
    underline)
      col=4
    ;;
    blink)
      col=5
    ;;
    inverted)
      col=7
    ;;
    stroke)
      col=9
    ;;
    black)
      col=30
    ;;
    red)
      col=31
    ;;
    green)
      col=32
    ;;
    yellow)
      col=33
    ;;
    blue)
      col=34
    ;;
    purple)
      col=35
    ;;
    cyan)
      col=36
    ;;
    black_bg)
      col=40
    ;;
    red_bg)
      col=41
    ;;
    green_bg)
      col=42
    ;;
    yellow_bg)
      col=43
    ;;
    blue_bg)
      col=44
    ;;
    purple_bg)
      col=45
    ;;
    cyan_bg)
      col=46
    ;;
    grey_bg)
      col=47
    ;;
    reset)
      col=0
    ;;
  esac
  if [[ "$col" != "" ]]; then string="$string$part1$col$part2"; fi
 done

 if [[ "$string" != "" ]]; then
  echo -ne "$string"
 fi
}

get_block_time(){
  BLOCK_HASH=`$CLI getblockhash $1`
  BLOCK=`$CLI getblock $BLOCK_HASH`
  BLOCK_TIME=`echo $BLOCK | jq '.time'`
  echo -n $BLOCK_TIME
}


####################
# INIZIO PROGRAMMA #
####################

clear
echo "Checking bitcoind daemon..."

# Verifica se il processo è in esecuzione
if ps -ef | grep "$daemon" | grep -v grep > /dev/null; then
  echo "$daemon è già in esecuzione"
else
 echo -n "Launching daemon"; waitecho 10
 RUN=`/usr/local/bin/bitcoind -daemon --datadir=$BLOCKCHAIN`
 echo -n "Daemon launched, please wait"; waitecho 10
fi

  ################################
  ################################
  ##                            ##
  ##    BEGINNIG OF THE LOOP    ##
  ##                            ##
  ################################
  ################################


while :
do

if [ $firstrun == true ] ; then
 echo "Getting blockchain info..."
fi

BC=`$CLI getblockchaininfo`
if [ $? == 0 ]; then
  read_ok=true
else
  read_ok=false
fi
if [ $read_ok = true ] ; then
  if [ $firstrun == true ] ; then
   echo "Getting network info..."
  fi
  NW=`$CLI getnetworkinfo`

  CHAIN=`echo $BC | jq '.chain'`
  BLOCKS=`echo $BC | jq '.blocks'`
  HEADERS=`echo $BC | jq '.headers'`
  SIZE=`echo $BC | jq '.size_on_disk'`
  CHAIN=`echo $BC | jq '.chain'`

  VERSION=`echo $NW | jq '.version'`
  SUBVERSION=`echo $NW | jq '.subversion'`
  ACTIVE=`echo $NW | jq '.networkactive'`
  CONNECTIONS_TOT=`echo $NW | jq '.connections'`
  CONNECTIONS_IN=`echo $NW | jq '.connections_in'`
  CONNECTIONS_OUT=`echo $NW | jq '.connections_out'`

  MANCANTI=$((HEADERS-BLOCKS))
  blocchi_totali=$(print_number $HEADERS)
  blocchi_locali=$(print_number $BLOCKS)
  blocchi_mancanti=$(print_number $MANCANTI)
  LAST_BLOCK_NUMBER=$BLOCKS

##################
# VALORE BTC EUR #
##################


  BTCPRICE=$(curl -m 10 -s "$EXT_URL")
  if [ $? -ne 0 ]; then
    BTCPRICETXT="Prezzo BTC non disponibile"
  else
    EURPRICETXT=""
    #echo "...done"
    BTCPRICE24H=`echo $BTCPRICE | jq '.price_24h'`
    BTCPRICELAST=`echo $BTCPRICE | jq '.last_trade_price'`
    BTCPRICECHANGE=$( echo "scale=2; ($BTCPRICELAST * 100 / $BTCPRICE24H) - 100" | bc)
    BTCPRICECHANGE=$(printf "%.2f" $BTCPRICECHANGE)
    BTCPRICEFORMAT=$(echo "$BTCPRICELAST/1" | bc)
    BTCPRICEFORMAT=$(print_number $BTCPRICEFORMAT)

    #Simbolo BTC
    #BTCSYM=$(echo -e "\u20BF ") #Sarebbe quello corretto ma potrebbe non funzionare
    BTCSYM=$(echo -e "\u0042 ")

    #Simbolo Sats
    #SATSYM=$(echo -e "\u2250 ") #Sarebbe quello corretto ma potrebbe non funzionare
    SATSYM=$(echo -e "\u015F ")

    #Simbolo Euro
    EURSYM=$(echo -e "\u20AC ")

    BTCSATS=100000000
    BTCPRICETXT="1$BTCSYM $EURSYM$BTCPRICEFORMAT (%$BTCPRICECHANGE)"
    PRICECHECK=$(echo "$BTCPRICELAST > $BTCPRICE24H" | bc -l)
    if [ $PRICECHECK -eq 1 ]; then
      BTCCOLOR="green"
    else
      BTCCOLOR="red"
    fi

    ### CONVERSIONE EURO/SATS #############
    firstcycle=true
    for euro in "${EURO[@]}"; do
      EUR_CONV=$(echo "$euro*$BTCSATS/$BTCPRICELAST" | bc)
      if [ $EUR_CONV -gt 10000000 ]; then
        EUR_CONV=$(echo "scale=3; $EUR_CONV/$BTCSATS" | bc)
        EUR_CONV=$(printf "%.3f" $EUR_CONV)
        SYMBOL=$BTCSYM
      else
        SYMBOL=$SATSYM
      fi
      EUR_CONV=$(print_number $EUR_CONV)
      euro=$(print_number $euro)
      if [ $firstcycle == false ]; then EURPRICETXT+=$(echo -n " | "); fi
      EURPRICETXT+=$(echo -n "€$euro = $SYMBOL$EUR_CONV")
      firstcycle=false
    done
    ########################################

  fi

##################


  if [ $firstrun == true ] ; then
   echo "Getting last blocks info..."
  fi

  if [[ $MANCANTI -gt 0 ]]; then
    HOW_MANY_BLOCKS=1
  else
    HOW_MANY_BLOCKS=$BLOCKS_LIST_DIM
  fi

  for ((i=0;i<$HOW_MANY_BLOCKS;i++))
  do
    BLOCK_NUMBER=$((LAST_BLOCK_NUMBER-i))
    if [ $firstrun == true ]; then
      NUM=$((i+1))
      echo "[$BLOCK_NUMBER($NUM/$HOW_MANY_BLOCKS)]"
    fi
    if [ -z "${BLOCK_HEIGHT[$BLOCK_NUMBER]}" ]; then
      BLOCK_HASH=`$CLI getblockhash $BLOCK_NUMBER`
      BLOCK=`$CLI getblock $BLOCK_HASH`
      BLOCK_SIZE[$BLOCK_NUMBER]=`echo $BLOCK | jq '.size'`
      BLOCK_TIME[$BLOCK_NUMBER]=`echo $BLOCK | jq '.time'`
      BLOCK_HEIGHT[$BLOCK_NUMBER]=`echo $BLOCK | jq '.height'`
      BLOCK_NTX[$BLOCK_NUMBER]=`echo $BLOCK | jq '.nTx'`
      BLOCK_CONF[$BLOCK_NUMBER]=`echo $BLOCK | jq '.confirmations'`
    fi
  done
  echo

  ### CALCOLO IL NUMERO MEDIO DI TRANSAZIONI PER BLOCCO
  tot_tx=0
  for tx_num in "${BLOCK_NTX[@]}"; do
    tot_tx=$((tot_tx + tx_num))
  done
  num_blocchi=${#BLOCK_NTX[@]}
  media_tx_per_block=$((tot_tx / num_blocchi))
  ###

fi

if [ $firstrun == false ] ; then 
 clear
fi

if [ $read_ok == true ] ; then
### UPTIME ######
  UPTIME_SEC=$($CLI uptime)
  UPTIME=$(seconds_converter $UPTIME_SEC)
#################
fi

DATA=$(date "+%A, %d %b %Y")
ORA=$(date "+%H:%M")



echo
change_color bold red_bg
fullrow "*"
lcr_text "$DATA" "$TITLE" "$ORA"
fullrow "*"
change_color reset
echo

if [ $read_ok == true ] ; then
 VER=$(echo "Versione corrente: $VERSION $SUBVERSION")
 UPT=$(echo "Uptime: $UPTIME")
 lr_text "$VER" "$UPT"

 HR_SIZE=$(human_readable_bytes $SIZE)
 SIZE_LABEL="Dimensione Blockchain: $HR_SIZE"


 STATUS_LABEL="Stato del network: "
 if [ $ACTIVE == true ] ; then
   STATUS="ATTIVO"
   CONNECTIONS="Connessioni in<>out: $CONNECTIONS_IN<>$CONNECTIONS_OUT"

 else
   STATUS="NON ATTIVO"
   CONNECTIONS=""
 fi

 lr_text "$STATUS_LABEL$STATUS" "$SIZE_LABEL"
 lr_text "$CONNECTIONS" "$BTCPRICETXT" "" "$BTCCOLOR bold"

 if [[ $MANCANTI -gt 0 ]]; then
  BLOCCHI_LTEXT="Blocchi totali/locali: $blocchi_totali / $blocchi_locali"
  BLOCCHI_RTEXT="Mancanti: $blocchi_mancanti"
 else
  BLOCCHI_LTEXT="Blocchi totali: $blocchi_totali"
  MINED=$(mined_bitcoins $BLOCKS)
  bitcoin_minati=$(print_number $MINED)
  PERCENT=$(echo "scale=2; $MINED * 100 / 21000000" | bc)
  BLOCCHI_RTEXT="Bitcoin totali minati: $bitcoin_minati ($PERCENT%)"
 fi
 lr_text "$BLOCCHI_LTEXT" "$BLOCCHI_RTEXT"
 lr_text "" "$EURPRICETXT" "" "cyan bold"
 echo

 NOW=$(date +%s)
 LB_TIME=${BLOCK_TIME[$LAST_BLOCK_NUMBER]}
 SEC_FROM_LAST_BLOCK=$((NOW - LB_TIME))
 TIME_FROM_LAST_BLOCK=$(seconds_converter $SEC_FROM_LAST_BLOCK)

################
###   INFO   ###
################
  MP=`$CLI getmempoolinfo`
  MP_LOADED=`echo $MP | jq '.loaded'`
  MP_SIZE=`echo $MP | jq '.size'`
  MP_TX_NUM=$(print_number $MP_SIZE)
  MP_BYTES=`echo $MP | jq '.bytes'`
  MP_HR_BYTES=$(human_readable_bytes $MP_BYTES)
  MP_USAGE=`echo $MP | jq '.usage'`
  MP_FEES=`echo $MP | jq '.total_fee'`

  #### FEES ###################################
  FEES_TXT="Stima fees (blocchi->sat/vB)"
  for num_block_fees in "${STIMA_BLOCCHI[@]}"; do
    STIMA=`$CLI estimatesmartfee $num_block_fees`
    FEE_BTC=$(echo "$STIMA" | jq -c '.feerate' | xargs printf "%f")
    FEE_SATS_KVB=$(echo "($FEE_BTC * 100000000)/1" | bc)
    FEE_SATS_VB=$(echo "scale=2; $FEE_SATS_KVB/1024" | bc)
    FEES_TXT+=" | $num_block_fees -> $FEE_SATS_VB"
  done
  ##############################################


  if [[ $media_tx_per_block -eq 0 ]]; then
    ntx_medie_txt=""
    n_blocchi_txt=""
  else
    ntx_medie_txt="Media transazioni per blocco: $media_tx_per_block"
    n_blocchi=$((MP_SIZE/media_tx_per_block))
    n_blocchi_txt="Stima blocchi nella mempool: $n_blocchi"
  fi

  ntx_txt="Numero transazioni in mempool: $MP_TX_NUM"
  dim_tx_txt="Dimensione totale transazioni: $MP_HR_BYTES"

  change_color bold red_bg
  centertext_fullrow "INFO" "*"
  change_color reset
  echo
  lr_text "$ntx_txt" "$ntx_medie_txt"
  lr_text "$dim_tx_txt" "$n_blocchi_txt"
  lr_text "Fees totali: $MP_FEES BTC" "$FEES_TXT" "" "purple bold"
  echo

###########################
## DIFFICULTY ADJUSTMENT ##
###########################

MINING=`$CLI getmininginfo`
DIFFICULTY=`echo $MINING | jq '.difficulty'`
HR_DIFF=$(human_readable_number "$DIFFICULTY")

PREV_BLOCK_DIFF=$((LAST_BLOCK_NUMBER - 2016))
PREV_BLOCK_DIFF_HASH=`$CLI getblockhash $PREV_BLOCK_DIFF`
PBD=`$CLI getblock $PREV_BLOCK_DIFF_HASH`
PBD_DIFF=`echo $PBD | jq '.difficulty'`
HR_PREV_DIFF=$(human_readable_number "$PBD_DIFF")
DIFF_CHANGE=$(echo "scale=2; ( $DIFFICULTY * 100 / $PBD_DIFF) - 100" | bc)
CHECK_DIFF=$(echo "$DIFF_CHANGE * 100 / 1" | bc)
if [[ $CHECK_DIFF -gt 0 ]]; then DIFF_CHANGE="+$DIFF_CHANGE"; fi

if [[ $MANCANTI -eq 0 ]]; then
 BLOCKS_FROM_DIFF_CHANGE=$(($LAST_BLOCK_NUMBER % 2016))
 LAST_DIFF_CHANGE=$(($LAST_BLOCK_NUMBER-$BLOCKS_FROM_DIFF_CHANGE))
 NEXT_DIFF_CHANGE=$(($LAST_DIFF_CHANGE+2016))
 BLOCKS_TO_DIFF_CHANGE=$(($NEXT_DIFF_CHANGE-$LAST_BLOCK_NUMBER))

 LAST_DIFF_HASH=`$CLI getblockhash $LAST_DIFF_CHANGE`
 LD=`$CLI getblock $LAST_DIFF_HASH`
 LD_TIME=`echo $LD | jq '.time'`
 if [[ $BLOCKS_FROM_DIFF_CHANGE -eq 0 ]]; then
   TEMPO_MEDIO_SEC=600
 else
   TEMPO_MEDIO_SEC=$(((LB_TIME - LD_TIME) / (LAST_BLOCK_NUMBER - LAST_DIFF_CHANGE)))
 fi

 BLOCCHI_ORA=$( echo "scale=2; 3600 / $TEMPO_MEDIO_SEC" | bc)
 BLOCCHI_GIORNO=$( echo "scale=0; 3600*24 / $TEMPO_MEDIO_SEC" | bc)
 BLOCCHI_SETTIMANA=$( echo "scale=0; 3600*24*7 / $TEMPO_MEDIO_SEC" | bc)
 BLOCCHI_MESE=$( echo "scale=0; 3600*24*30 / $TEMPO_MEDIO_SEC" | bc)
 BLOCCHI_ANNO=$( echo "scale=0; 3600*24*365 / $TEMPO_MEDIO_SEC" | bc)
 SCARTO=$( echo "scale=2; 60000 / $TEMPO_MEDIO_SEC - 100" | bc)
 if [[ $TEMPO_MEDIO_SEC -lt 600 ]]; then SCARTO="+$SCARTO"; fi
 TEMPO_MEDIO=$(seconds_converter $TEMPO_MEDIO_SEC)
 if [[ $SEC_FROM_LAST_BLOCK -gt 600 ]]; then
   CORREZIONE=600
 else
   CORREZIONE=$SEC_FROM_LAST_BLOCK
 fi
 SEC_TO_DIFF_CHANGE=$((BLOCKS_TO_DIFF_CHANGE * TEMPO_MEDIO_SEC - CORREZIONE))
 SEC_TO_DIFF_CHANGE=$((SEC_TO_DIFF_CHANGE - (SEC_TO_DIFF_CHANGE % 60) + 60 )) #arrotondo a minuti
 TIME_TO_DIFF_CHANGE=$(seconds_converter $SEC_TO_DIFF_CHANGE)
 LAST_DIFF_DATE=$(readable_date $LD_TIME)
 NEXT_DIFF_DATE=$((NOW + SEC_TO_DIFF_CHANGE))


 NEXT_DIFF_DATE=$(readable_date $NEXT_DIFF_DATE)

 change_color bold red_bg
 centertext_fullrow "DIFFICULTY" "*"
 change_color reset
 echo
 change_color bold cyan
 difficulty_progress $LAST_BLOCK_NUMBER 2
 change_color reset
 lr_text "$LAST_DIFF_DATE" "$NEXT_DIFF_DATE"
 echo

 LTEXT="Tempo medio per blocco: $TEMPO_MEDIO"
 RTEXT="B/h: $BLOCCHI_ORA | B/d: $BLOCCHI_GIORNO | B/W: $BLOCCHI_SETTIMANA | B/M: $BLOCCHI_MESE | B/Y: $BLOCCHI_ANNO"
 lr_text "$LTEXT" "$RTEXT"

 lr_text "Current difficulty: $HR_DIFF" "Adjustement stimato: $SCARTO%"
 lr_text "Previous difficulty: $HR_PREV_DIFF" "Adjustement precedente: $DIFF_CHANGE%"
 echo -n "Prossimo difficulty adjustment stimato fra: "
 change_color bold purple underline
 echo -n "$TIME_TO_DIFF_CHANGE"
 change_color reset
 echo
 echo
fi


if [[ $MANCANTI -eq 0 ]]; then


#############
## HALVING ##
#############

  BLOCKS_FROM_HALVING=$(($LAST_BLOCK_NUMBER % 210000))
  LAST_HALVING=$(($LAST_BLOCK_NUMBER-$BLOCKS_FROM_HALVING))
  NEXT_HALVING=$(($LAST_HALVING + 210000))
  BLOCKS_TO_HALVING=$(($NEXT_HALVING - $LAST_BLOCK_NUMBER))

  #LAST_HALV_HASH=`$CLI getblockhash $LAST_HALVING`
  #LH=`$CLI getblock $LAST_HALV_HASH`
  #LH_TIME=`echo $LH | jq '.time'`

  LH_TIME=$(get_block_time $LAST_HALVING)
  first_block=0
  first_block_time=$(get_block_time $first_block)
  #LB_TIME=${BLOCK_TIME[$LAST_BLOCK_NUMBER]}
  tempo_medio_blocco=$(( (LB_TIME - first_block_time) / (LAST_BLOCK_NUMBER - first_block) ))
  TEMPO_MEDIO_BLOCCHI=$(seconds_converter $tempo_medio_blocco)
  halv_row2=""
  ciclo_corrente=$((LAST_BLOCK_NUMBER / 210000))
  tempo_medio_ciclo_sec=$(( (LH_TIME - first_block_time) / ciclo_corrente ))
  tempo_medio_ciclo_time=$(seconds_converter $tempo_medio_ciclo_sec)

  ###PREVISIONE HALVING ###

  ### METODO 1 ###
if [[ $metodo -eq 1 ]]; then
  BLOCKS_MEDIA=210000

  if [[ $LAST_BLOCK_NUMBER -lt $BLOCKS_MEDIA ]]; then BLOCKS_MEDIA=$((LAST_BLOCK_NUMBER-1)); fi
  FIRST_BLOCK_NUM=$((LAST_BLOCK_NUMBER - BLOCKS_MEDIA))
  FIRST_BLOCK_HASH=`$CLI getblockhash $FIRST_BLOCK_NUM`
  FB=`$CLI getblock $FIRST_BLOCK_HASH`
  FB_TIME=`echo $FB | jq '.time'`
  TEMPO_MEDIO_HALV_SEC=$(( (LB_TIME - FB_TIME) / BLOCKS_MEDIA ))
  TEMPO_MEDIO_HALV=$(seconds_converter $TEMPO_MEDIO_HALV_SEC)

  SECS_TO_HALVING=$((BLOCKS_TO_HALVING * TEMPO_MEDIO_HALV_SEC))
  TIME_TO_HALVING=$(seconds_converter $SECS_TO_HALVING)

  ### METODO 2 ###
elif [[ $metodo -eq 2 ]]; then
  REF_BLOCK_NUM=$(($LAST_HALVING - $BLOCKS_TO_HALVING))
  REF_BLOCK_HASH=`$CLI getblockhash $REF_BLOCK_NUM`
  RB=`$CLI getblock $REF_BLOCK_HASH`
  RB_TIME=`echo $RB | jq '.time'`
  LAST_HALVING_TIME_TAKEN=$((LH_TIME - RB_TIME))

  SECS_TO_HALVING=$LAST_HALVING_TIME_TAKEN
  TIME_TO_HALVING=$(seconds_converter $SECS_TO_HALVING)

  ### METODO 3 ###
elif [[ $metodo -eq 3 ]]; then
  SECS_TO_HALVING=$((TEMPO_MEDIO_SEC*BLOCKS_TO_HALVING))
  TIME_TO_HALVING=$(seconds_converter $SECS_TO_HALVING)

  ### METODO 4 ###
elif [[ $metodo -eq 4 ]]; then
  halv_block=210000
  ref_block=$((halv_block-BLOCKS_TO_HALVING))
  min_time=0
  max_time=0
  tempo_medio=0

  for (( i=1 ; i <= $ciclo_corrente ; i++ )); do
    halv_block_time=$(get_block_time $halv_block)
    ref_block_time=$(get_block_time $ref_block)
    halv_time=$((halv_block_time - ref_block_time))
    tempo_medio=$((tempo_medio + halv_time))
    if [[ $min_time -eq 0 ]]; then
      min_time=$halv_time
    fi
    if [[ $halv_time -lt $min_time ]]; then min_time=$halv_time; fi
    if [[ $halv_time -gt $max_time ]]; then max_time=$halv_time; fi
    halv_block=$((halv_block + 210000))
    ref_block=$((ref_block + 210000))
  done
  tempo_medio=$(( tempo_medio / ciclo_corrente ))
  tempo_medio_time=$(seconds_converter $tempo_medio)
  next_halv_mid_time=$((LB_TIME + tempo_medio))
  next_halv_low_time=$((LB_TIME + min_time))
  next_halv_high_time=$((LB_TIME + max_time))
  next_halv_mid_date=$(readable_date $next_halv_mid_time)
  next_halv_low_date=$(readable_date $next_halv_low_time)
  next_halv_high_date=$(readable_date $next_halv_high_time)
  TIME_TO_HALVING=$tempo_medio_time
  next_halv_text="$next_halv_low_date <> $next_halv_high_date"
  halv_row2="Previsione: $next_halv_mid_date"
fi




  LAST_HALV_DATE=$(readable_date $LH_TIME)
  NEXT_HALV_DATE=$((NOW + SECS_TO_HALVING))
  NEXT_HALV_DATE=$(readable_date $NEXT_HALV_DATE)

  if [[ $metodo -eq 4 ]]; then
    NEXT_HALV_DATE=$next_halv_text
  fi

  change_color bold red_bg
  centertext_fullrow "HALVING" "*"
  change_color reset
  echo
  change_color bold cyan
  halving_progress $LAST_BLOCK_NUMBER 2
  change_color reset
  lr_text "$LAST_HALV_DATE" "$NEXT_HALV_DATE"
  lr_text "" "$halv_row2"
  REWARD=$(get_reward $LAST_BLOCK_NUMBER)
  REWARD_TXT="Reward attuale: $REWARD BTC"
  lr_text "$REWARD_TXT" ""
  echo -n "Tempo medio di tutti i blocchi: "
  change_color bold green
  echo -n "$TEMPO_MEDIO_BLOCCHI"
  change_color reset
  echo
  lr_text "Prossimo halving stimato fra: $TIME_TO_HALVING" "Durata media ciclo: $tempo_medio_ciclo_time"
  echo
 fi


###########
## BLOCK ##
###########

  NOW=$(date +%s)
  LB_TIME=${BLOCK_TIME[$LAST_BLOCK_NUMBER]}
  SEC_FROM_LAST_BLOCK=$((NOW - LB_TIME))
  TIME_FROM_LAST_BLOCK=$(seconds_converter $SEC_FROM_LAST_BLOCK)

 if [[ $HOW_MANY_BLOCKS -gt 1 ]]; then
   change_color bold red_bg
   centertext_fullrow "ULTIMI BLOCCHI" "*"
   change_color reset
   echo
   COL1="BLOCK"
   COL2="TIME"
   COL3="TIME TO NEXT"
   COL4="SIZE"
   COL5="TRANSACTIONS"

   ## COLOR FORMAT ##
   str1=$(change_color bold yellow underline)
   str2=$(change_color reset)
   FCOL1="$str1$COL1$str2"
   ##################

   SIZE1=${#BLOCKS}; SIZE1=$((SIZE1 + 2));
   if [[ $SIZE1 -lt ${#COL1} ]]; then SIZE1=${#COL1}; fi
   SIZE2=8 #hh:mm:ss
   SIZE3=14  #xxh yym zzs
   SIZE4=10   #0000 XB
   SIZE5=12

   FORMAT1="%2s %-"$SIZE1"s %3s %-"$SIZE2"s %3s %-"$SIZE3"s %3s %-"$SIZE4"s %3s %-"$SIZE5"s %2s"
   FORMAT2="%2s %"$SIZE1"s %3s %"$SIZE2"s %3s %"$SIZE3"s %3s %"$SIZE4"s %3s %"$SIZE5"s %2s"

   #change_color bold
   printf "$FORMAT1\n" "| " "$COL1" " | " "$COL2" " | " "$COL3" " | " "$COL4" " | " "$COL5" " |"
   #change_color reset

   for ((i=0;i<$HOW_MANY_BLOCKS;i++))
   do
     THIS_BLOCK_NUMBER=$((LAST_BLOCK_NUMBER - i))
     if [[ $i -eq 0 ]]; then
       THIS_BLOCK_TIMESTAMP=${BLOCK_TIME[$THIS_BLOCK_NUMBER]}
       THIS_BLOCK_TIME="($TIME_FROM_LAST_BLOCK fa)"
     else
       NEXT_BLOCK_TIMESTAMP=$THIS_BLOCK_TIMESTAMP
       THIS_BLOCK_TIMESTAMP=${BLOCK_TIME[$THIS_BLOCK_NUMBER]}
       THIS_BLOCK_TIME_SEC=$((NEXT_BLOCK_TIMESTAMP - THIS_BLOCK_TIMESTAMP))
       THIS_BLOCK_TIME=$(seconds_converter $THIS_BLOCK_TIME_SEC)
     fi
     THIS_BLOCK_NUM=${BLOCK_HEIGHT[$THIS_BLOCK_NUMBER]}
     THIS_BLOCK_SIZE=${BLOCK_SIZE[$THIS_BLOCK_NUMBER]}
     THIS_BLOCK_NTX=${BLOCK_NTX[$THIS_BLOCK_NUMBER]}
     THIS_BLOCK_ORE=$(date -d @"$THIS_BLOCK_TIMESTAMP" +"%H:%M:%S")
     THIS_BLOCK_SIZE_HR=$(human_readable_bytes $THIS_BLOCK_SIZE)

     printf "$FORMAT2\n" "| " "#$THIS_BLOCK_NUM" " | " "$THIS_BLOCK_ORE" " | " "$THIS_BLOCK_TIME" " | " "$THIS_BLOCK_SIZE_HR" " | " "$THIS_BLOCK_NTX" " |"
   done
 else
   LB_NUM=$LAST_BLOCK_NUMBER
   LB_TIME=${BLOCK_TIME[$LAST_BLOCK_NUMBER]}
   LB_SIZE=${BLOCK_SIZE[$LAST_BLOCK_NUMBER]}
   LB_NTX=${BLOCK_NTX[$LAST_BLOCK_NUMBER]}
   change_color bold red_bg
   centertext_fullrow "ULTIMO BLOCCO" "*"
   change_color reset
   echo
   echo "Blocco numero: $LB_NUM"
   READABLE_DATE=$(readable_date $LB_TIME)
   echo "Aggiunto il: $READABLE_DATE ($TIME_FROM_LAST_BLOCK fa)"
   echo "Hash: $BLOCK_HASH"
   LB_SIZE_HR=$(human_readable_bytes $LB_SIZE)
   echo "Dimensione: $LB_SIZE_HR"
   echo "Numero di transazioni: $LB_NTX"
 fi

 WAIT_TIME=$REFRESH
 firstrun=false
else
 echo "Errore nella lettura della blockchain"
 echo "Stato del network: NON ATTIVO"
 WAIT_TIME=$WAIT_ON_ERROR
fi

 echo
 change_color bold red_bg
 fullrow "*"
 change_color reset

 change_color light
 waitbar $WAIT_TIME
 change_color reset

 if [ $firstrun == true ]; then
  clear
 fi

### Cancello i blocchi vecchi dall'array
if [ ${#BLOCK_HEIGHT[@]} -gt $HOW_MANY_BLOCKS ]; then
  for blocco in ${!BLOCK_HEIGHT[@]}; do
    exclude=$((LAST_BLOCK_NUMBER-HOW_MANY_BLOCKS))
    if [ $blocco -le $exclude ]; then
      unset BLOCK_HEIGHT["$blocco"]
      unset BLOCK_SIZE["$blocco"]
      unset BLOCK_TIME["$blocco"]
      unset BLOCK_NTX["$blocco"]
      unset BLOCK_CONF["$blocco"]
    fi
  done
fi
###

done
